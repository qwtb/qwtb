function [P_st, P_inst] = flicker_sim(u, fs, f_line, verbose)
% [P_ST, P_INST] = flicker_sim(U, FS, F_LINE, VERBOSE)
% Flickermeter simulator according IEC 61000-4-15 [1] and [2].
% Calculates instantaneous flicker sensation P_INST and short-term
% flicker severity P_ST. For best performance, observation time
% of the U series must be greater than 600 seconds. Calculated
% instantaneous flicker severity values before last 600 seconds
% are not taking into account. Requires either Signal Procesing
% Toolbox when run in MATLAB or signal package when run in GNU
% Octave. 
%
% The sampling frequency should be between 7.5 and 23 kHz (errors
% of max(Pinst) is below 1.8 % and Pst below 0.8 % at values
% tabulated by the standard), this is already comparable to the
% precision level of the IEC standard. Optimal sampling frequency
% is 20 kHz (error of max(Pinst) is 1.1 % and Pst 0.62 %) The
% signal is automatically down sampled to fit the range if
% sampling frequency is too high.
%
% According Note 2 in Table 5 in IEC standard the signal should
% be synchronized in such a way that the flicker modulation
% should start in the first 5 seconds of last 10 minutes of the
% measured signal. This is up to user to guarantee this.
%
% Input variables:
%   U: Vector of voltage samples. For proper results should be
%     at least 720 s thus filters can be properly charged. See
%     reference [4].
%   FS: Sampling frequency of u in Hz. Should be 7-23 kHz. If
%     higher, signal is downsampled.
%   F_LINE: Line frequency in Hz. Must be 50 or 60 Hz.
%   VERBOSE: if set to 1 shows plots of P_INST and cumulative 
%     probability function, if set to 2 shows also responses
%     of filters (needs lot of memory). If set to -1, even
%     warnings are suppressed.
% 
% Output variables:
%   P_ST: Short-term flicker severity calculated from last 600 s
%     of voltage samples.
%   P_INST: Instantaneous flicker sensation.

% Last modified 25.3.2018
%
% This script file has been completed in the scope of 15RPT04
% TracePQM EMRP project and is derivative work of:
% 1, flicker_sim.m developed by Solcept AG [3].
% 2, Flicker calculation Labview VIs developed by National
%   Instruments.
%
% References:
% [1] IEC 61000-4-15, Electromagnetic compatibility (EMC), Testing and
%     measurement techniques, Flickermeter, Edition 2.0, 2010-08
% [2] Wilhelm Mombauer: "Messung von Spannungsschwankungen und Flickern mit
%     dem IEC-Flickermeter", ISBN 3-8007-2525-8, VDE-Verlag 
% [3] Solcept Open Source Flicker Measurement-Simulator
%     https://www.solcept.ch/en/tools/flickersim/
% [4] NPL Reference Flickermeter Design
%     http://www.npl.co.uk/electromagnetics/electrical-measurement/products-and-services/npl-reference-flickermeter-design
%
% 2DO: check if decimation by interpolation is good idea at end
% of block 4

% (c) Copyright 2009 Solcept AG
% (c) Copyright 2017 TÜBÝTAK UME Power&Energy Laboratory - Dr. Kaan Gülnihar
% (c) Copyright 2018 CMI - Dr. Martin Sira
% 
% Boost Software License - Version 1.0 - August 17th, 2003
% 
% Permission is hereby granted, free of charge, to any person or organization
% obtaining a copy of the software and accompanying documentation covered by
% this license (the "Software") to use, reproduce, display, distribute,
% execute, and transmit the Software, and to prepare derivative works of the
% Software, and to permit third-parties to whom the Software is furnished to
% do so, all subject to the following:
% 
% The copyright notices in the Software and this entire statement, including
% the above license grant, this restriction and the following disclaimer,
% must be included in all copies of the Software, in whole or in part, and
% all derivative works of the Software, unless such copies or derivative
% works are solely in the form of machine-executable object code generated by
% a source language processor.
% 
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
% FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
% SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
% FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
% ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
% DEALINGS IN THE SOFTWARE.

% check number of arguments:
if (nargin < 3 || nargin > 5)
  error('Invalid number of arguments');
end

% check voltage series:
if (~isvector(u))
  error('First input argument must be a vector of samples');
end
% convert to row vector if needed
u = reshape(u, 1, length(u));

% check line frequency:
if ((f_line ~= 50) && (f_line ~= 60))
  error('Line frequency must be 50 or 60 Hz');
end

% set value of verbose:
if (nargin < 4)
        verbose = 0;
end

%% Check if running in Matlab or GNU Octave:
IS_OCTAVE = (exist('OCTAVE_VERSION') ~= 0);

%% Check available packages
if IS_OCTAVE
        if not(exist('butter'))
                pkg load signal
                if not(exist('butter'))
                        error('This algorithm requires package `signal` from Octave Forge');
                end
        end
else
        if not(exist('butter'))
                error('This algorithm requires `Signal Processing Toolbox`');
        end
end

%% Downsampling
% to be ok with standard, the sampling frequency should be 2 - 33 kHz.
% to be below 0.01 error, the sampling f should be 7 - 23 kHz.
% minimum usable sampling frequency:
fsmin = 7e3;
fsmin = 1e3; %XXX
% maximum usable sampling frequency:
fsmax = 23e3;
fsmax = 60e3; %XXX
% optimal usable sampling frequency:
fsoptim = 17e3;

if fs < fsmin
        error(['Sampling frequency (fs) is too low! Use fs in range ' num2str(fsmin) ' - ' num2str(fsmax) ' kHz to get result. If fs is greater, the signal will be downsampled, this have some impact on precision. Optimally use fs = ' num2str(fsoptim) ' kHz.']);
end
if fs > fsmax
        if verbose > -1
                warning(['Sampling frequency (fs) is too high! Use fs in range ' num2str(fsmin) ' - ' num2str(fsmax) ' kHz to get result. fs is greater and the signal will be downsampled, this have some impact on precision. Optimally use fs = ' num2str(fsoptim) ' kHz.']);
        end
        tic
        % get downsampling ratio:
        R = fs./fsoptim;
        % find best integer ratio number in a range of possible ratios:
        R = [floor(R)-[2 1] floor(R) ceil(R) ceil(R)+[1 2]];
        R = R(R>0);
        fid = fs./R >= fsmin & fs./R <= fsmax;
        R = R(fid);
        [tmp fid] = min(abs(fs./R - fsoptim));
        if not(isempty(fid))
                fid = fid(1);
                R = R(fid);
        else
                R = [];
        end
        % check the ratio:
        if isempty(R)
                error('Downsampling integer ratio was not found. Probably resample is needed, maybe this script can be improved.')
        else
                disp(['Downsampling to fs = ' num2str(fs./R) ' kHz.']);
        end
        u = resample(u, 1, R);
        fs = fs./R;
        calctime = toc;
        if verbose > 0
                fprintf(1,'%.2f seconds\nPreparation of input signal...', calctime) 
        end
end
tic;
if verbose > 0
        fprintf(1,'Preparation of input signal...') 
end

%% Preparation of input signal
% remove DC component (not precise if modulation and signal periods are not whole)
u = u - mean(u);
% RMS value - only used for voltage level determination (120V or 230V) in Block 3B
% (for fs=2 kHz and 11 minutes of signal the error of RMS value is ~10^-10 if signal do not contain whole periods)
u_rms = rms(u);
% Calculation of the observation time
Observation_interval = round((numel(u) - 1) / fs);

%% zero crossing detector
% cut off frequency
fc=[50 60];
% low pass butterworth filter
% this filter will be used only for zero crossing detection,
% for rest of calculations original signal will be used
if IS_OCTAVE
        [b,a]=butter ( 1, fc / (fs/2));
else
        [b,a]=butter ( 1, fc / (fs/2), 'bandpass' );
end
% there and back filter to decrease phase error:
us = filtfilt(b, a, u);
if verbose > 0
        % save one second of original signal for zero crossing plot
        u_orig = u(1:fs);
        % save one second of filtered signal for zero crossing plot
        u_filt = us(1:fs);
end

us = sign(us);
us = [diff(us) 0];
zero_crossing_indexes = find(us ~= 0);
clear us;
zero_crossings = length(zero_crossing_indexes);

%% half rms calculation

for i = 1 : (zero_crossings - 1)
    u_half_rms(i) = sqrt(mean(u((zero_crossing_indexes(i)):(zero_crossing_indexes(i+1)-1)).^2));
end

%% Block 1: Input voltage adaptor
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 1: Input voltage adaptor...', calctime) 
end

vector_1(1) = ((6999/7000) * u_half_rms(1)) + (u_half_rms(1) / 7000);

for i = 2 : length(u_half_rms)
    vector_1(i) = ((6999/7000) * vector_1(i-1)) + (u_half_rms(i) / 7000);
end

vector_1_rms = rms(vector_1);

if(vector_1_rms == 0)
    vector_1_rms = 1e-12;
end

block_1_multiplier = 23.575 / vector_1_rms;

u = block_1_multiplier * u;

%% Block 2: Quadratic demodulator
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 2: Quadratic demodulator...', calctime) 
end

u = u .^ 2;

%% Block 3: Bandpass and weighting filter
%% Block 3A: bandpass filter
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 3A: Bandpass filter...', calctime) 
end

LPF_order = 6;

if (f_line == 50)
  LPF_cutoff = 35;
end
if (f_line == 60)
  LPF_cutoff = 42;
end

HPF_order = 1;
HPF_cutoff = 0.05;

u = u - mean(u);

[b_lpf, a_lpf] = butter(LPF_order, LPF_cutoff/(fs/2), 'low');
u_lpf = filter(b_lpf, a_lpf, u);
u = u_lpf;
u = downsample(u,4); % At this point, signal is downsampling by 1/4 ratio

[b_hpf, a_hpf] = butter(HPF_order, HPF_cutoff/(fs/8), 'high');
u_hpf = filter(b_hpf, a_hpf, u);
u = u_hpf;

%% Block 3B: weighting filter
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 3B: Weighting filter...', calctime) 
end

if (u_rms < 140 && u_rms > 100)
    SYS_VOLTAGE = 120;
elseif (u_rms < 250 && u_rms > 210)
    SYS_VOLTAGE = 230;
else
    error(['RMS voltage ' num2str(u_rms) ' is outside ranges 100 - 140 or 210 - 250. System voltage unknown!'])
end

if (SYS_VOLTAGE == 230)
  K = 1.74802;
  LAMBDA = 2 * pi * 4.05981;
  OMEGA1 = 2 * pi * 9.15494;
  OMEGA2 = 2 * pi * 2.27979;
  OMEGA3 = 2 * pi * 1.22535;
  OMEGA4 = 2 * pi * 21.9;
end
if (SYS_VOLTAGE == 120)
  K = 1.6357;
  LAMBDA = 2 * pi * 4.167375;
  OMEGA1 = 2 * pi * 9.077169;
  OMEGA2 = 2 * pi * 2.939902;
  OMEGA3 = 2 * pi * 1.394468;
  OMEGA4 = 2 * pi * 17.31512;
end

num1 = [K * OMEGA1, 0];
den1 = [1, 2 * LAMBDA, OMEGA1.^2];
num2 = [1 / OMEGA2, 1];
den2 = [1 / (OMEGA3 * OMEGA4), 1 / OMEGA3 + 1 / OMEGA4, 1];

if IS_OCTAVE
        [b_lamp, a_lamp] = bilinear(conv(num1, num2), conv(den1, den2), 1/(fs/4));
else
        [b_lamp, a_lamp] = bilinear(conv(num1, num2), conv(den1, den2), fs/4);
end
u_lamp = filter(b_lamp, a_lamp, u);
u = u_lamp;

%% Block 4: Squaring and smoothing
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 4: Squaring and smoothing...', calctime) 
end

u = u .^ 2;

LPF2_order = 1;
LPF2_cutoff = 1 / (2 * pi * 0.3);

[b_lpf2, a_lpf2] = butter(LPF2_order, LPF2_cutoff/(fs/8), 'low');
u_lpf2 = filter(b_lpf2, a_lpf2, u);
s = u_lpf2;

% data_start_point is the starting index of the last 600 seconds interval.
data_start_point = round((15 * fs * ((Observation_interval / 60) - 10)) + 1);
if data_start_point < 1
        error('Too short observation interval. Longer data are required!')
end
s = s(data_start_point:end);

% calculated_observation_interval is a control value for testing purposes.
% It shows the time interval which are taking into account, it is unused.
calculated_observation_interval = round(4*(numel(s)-1)/fs); % (seconds)

% *******************************
% ********* decimation **********
% (maybe functions like decimate or resample should be used here. these functions
% apply filters to prevent aliasing. however signals that could be aliased
% should not be present in the signal)
b = linspace(1, numel(s), 60000);
s = interp1(s,b,'linear');
% *******************************

P_inst = s;

%% Block 5: Statistical evaluation (Pst)
calctime = toc; tic;
if verbose  > 0
        fprintf(1,'%.2f seconds\nBlock 5: Statistical evaluation...', calctime) 
end

NUMOF_CLASSES = 702;
[bin_cnt, cpf.magnitude] = hist(P_inst, NUMOF_CLASSES);
cpf.cum_probability = 100 * (1 - cumsum(bin_cnt) / sum(bin_cnt));

p_50s = mean([get_percentile(cpf, 30), get_percentile(cpf, 50), get_percentile(cpf, 80)]);
p_10s = mean([get_percentile(cpf, 6), get_percentile(cpf, 8), ...
  get_percentile(cpf, 10), get_percentile(cpf, 13), get_percentile(cpf, 17)]);
p_3s = mean([get_percentile(cpf, 2.2), get_percentile(cpf, 3), get_percentile(cpf, 4)]);
p_1s = mean([get_percentile(cpf, 0.7), get_percentile(cpf, 1), get_percentile(cpf, 1.5)]);
p_0_1 = get_percentile(cpf, 0.1);

P_st = sqrt(0.0314 * p_0_1 + 0.0525 * p_1s + 0.0657 * p_3s + 0.28 * p_10s + 0.08 * p_50s);

%% Optional graphical output
if verbose > 0
  calctime = toc; tic;
  fprintf(1,'%.2f seconds\nPlotting Pinst and CPF...', calctime)

  % zero crossings detection
  figure
  % time vector: 
  tmp = zero_crossing_indexes(:)';
  tmpi = find(tmp < length(u_orig));
  tmp = tmp(1:tmpi(end));
  tmp = tmp(:)';
  hold on
  plot(u_orig, '-x');
  plot(u_filt, '-');
  plot([tmp; tmp], [min(u_orig).*ones(size(tmp)); max(u_orig).*ones(size(tmp))], '-r');
  plot([1 tmp(end)], [0 0], '-k');
  hold off
  legend('original', 'filtered', 'zero crossings')
  title('original signal and detected zero crossings');

  % signals
  figure
  plot(P_inst)
  xlabel('No of sample')
  ylabel('Pinst')
  title(['Pinst, sampling f = ' num2str(fs) ' Hz']);

  % cumulative probability function
  figure
  clf
  plot(cpf.magnitude, cpf.cum_probability);
  grid
  xlabel('Classes')
  ylabel('Cumulative probability (%)')
  title('Cumulative probability function');

  if verbose > 1
    calctime = toc; tic;
    fprintf(1,'%.2f seconds\nPlotting filter responses...', calctime)
    % frequency responses of filters
    %Return the complex frequency response of the rational IIR filter whose numerator and denominator
    %coefficients are B and A at frequencies W of sampling rate fs
    W=linspace(0.01,fs*2,fs*100);
    [h_hp, f] = freqz(b_hpf, a_hpf, W, fs);
    [h_lp, f] = freqz(b_lpf, a_lpf, W, fs);
    [h_lamp, f] = freqz(b_lamp, a_lamp, W, fs);
    [h_lp2, f] = freqz(b_lpf2, a_lpf2, W, fs);
    figure
    hold on
    plot(f, abs(h_hp), 'b')
    plot(f, abs(h_lp), 'r')
    plot(f, abs(h_lamp), 'g')
    plot(f, abs(h_lp2), 'm')
    hold off
    grid
    axis([0, 200, 0, 1.1]);
    title('Frequency responses of filters, magnitude');
    xlabel('f (Hz)');
    ylabel('Normalized response (V/V)');
    legend('h hp - B3 high pass', 'h bw - B3 butterworth', 'h w - B3 weighting', 'h lp - B4 low pass');

    figure
    hold on
    plot(f, 180 / pi * unwrap(angle(h_hp)), 'b')
    plot(f, 180 / pi * unwrap(angle(h_lp)), 'r')
    plot(f, 180 / pi * unwrap(angle(h_lamp)), 'g')
    plot(f, 180 / pi * unwrap(angle(h_lp2)), 'm')
    hold off
    grid
    axis([0, 200, -200, 300]);
    title('Frequency responses of filters, angle');
    xlabel('f (Hz)');
    ylabel('Angle');
    legend('h hp - B3 high pass', 'h bw - B3 butterworth', 'h w - B3 weighting', 'h lp - B4 low pass');
  end % if verbose > 1
  calctime = toc; tic;
  fprintf(1,'%.2f seconds\n', calctime)
end % if verbose

end

%% Subfunction: get_percentile
function val = get_percentile(cpf, limit)
  [dummy, idx] = min(abs(cpf.cum_probability - limit));
  val = cpf.magnitude(idx);
end

%% Subfunction: rms
function y=rms(x, dim)
  if nargin==1
    y = sqrt(mean(x.*conj(x)));
  else
    y = sqrt(mean(x.*conj(x), dim));
  end
end
